# 理解JavaScript中的LHS和RHS
<html><div class="articleTime">2020.01.14</div></html>

参考资料：凯尔·辛普森《你不知道的JavaScript（上卷）》
### 1. 编译原理
JavaScript引擎首先会在代码执行前对其进行编译
```
var a = 2
```
这行代码将被拆分成两个步骤：
1. `var a`
编译器会在当前作用域中声明一个变量（如果之前没有声明过）
2. `a = 2` 
运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

在查找变量的过程中，分为LHS和RHS两种查找方式。

### 2. LHS和RHS的概念
LHS和RHS的字面意思是Left Hand Side和Right Hand Side，于是有一种理解是把其当作运算符的左侧和右侧。
按照《你不知道的JavaScript》的说法是：
> 讲得更准确一点，RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。你可以将RHS理解成retrieve his source value（取到它的源值），这意味着“得到某某的值”。

所以，可以这样理解：
**LHS**：赋值操作的目标是谁，如：
```
a = 2
```
这里对a的引用则是LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为=2这个赋值操作找到一个目标。

**RHS**：赋值操作的源头是谁，如
```
console.log(a)
```
因为这里a并没有赋予任何值。相应地，需要查找并取得a的值，这样才能将值传递给console.log(..)

### 3. 二者结合的例子
```
function foo(a) {
    console.log(a)
}
foo(2)
```
找出其中所有的RHS查询：
1. `foo()` 需要查找到`foo`方法
2. `log()` 需要查找到console下的`log`方法

找出其中所有的LHS查询：
1. `a = 2` 这里存在隐式变量赋值，执行函数时，将2通过参数的形式赋值给a
2. 假设在`log(..)`函数的原生实现中它可以接受参数，在将2赋值给其中第一个（也许叫作arg1）参数之前，这个参数需要进行LHS引用查询。

再看另一个例子：
```
function foo(a) {
    var b = a;
    return a + b;
}
var c = foo(2);
```
1. 找出其中所有的LHS查询
    1. `c = ...` 赋值什么给c？
    2. `a = 2` 隐式变量分配
    3. `b = ...` 赋值什么给b？

2. 找出其中所有的RHS查询
    1. `foo(...)` 执行谁？
    2. `= a` a赋值给谁？
    3. `a...` a和谁进行运算？
    4. `...b` 谁和b进行运算？

#### 4. 遍历规则

LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。 

#### 5. 异常
```
function foo(a) {
    console.log(a+b)
    b = a
}

foo(2)
```
如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出`ReferenceError`异常。  
如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用`null`或`undefined`类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作`TypeError`。 

不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出`ReferenceError`异常（严格模式下）。

`ReferenceError`同作用域判别失败相关。  
`TypeError`代表作用域判别成功了，但是对结果的操作是非法或不合理的。